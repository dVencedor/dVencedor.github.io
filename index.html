<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Unit 6 - Earth & Moon Animation (Three.js)</title>
  <style>
    /* Fullscreen canvas with no scrollbars */
    html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!--
    Unit 6 Programming Assignment
    - Two textured spheres (Earth & Moon)
    - Animate rotation + orbit
    - Light source on the right to simulate sunlight/day-night
    - Moon orbit designed to pass between Earth and light (eclipse effect)
    - Mouse controls NOT required (and intentionally not included)
  -->

  <script type="module">
    /**************************************************************
     * 1) IMPORT THREE.JS
     * Using a CDN import. If your assignment environment provides
     * Three.js already, you may replace this with the provided import.
     **************************************************************/
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    /**************************************************************
     * 2) BASIC SCENE SETUP (Scene, Camera, Renderer)
     **************************************************************/
    const scene = new THREE.Scene();

    // Camera: perspective camera looking toward the origin (0,0,0)
    // FOV 45 gives a natural view for a simple solar-system demo.
    const camera = new THREE.PerspectiveCamera(
      45,                                // field of view
      window.innerWidth / window.innerHeight, // aspect ratio
      0.1,                               // near clip
      100                                // far clip
    );

    // Position the camera back a bit so we can see Earth and Moon
    camera.position.set(0, 1.5, 7);
    camera.lookAt(0, 0, 0);

    // Renderer: draws the scene into the canvas
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    /**************************************************************
     * 3) TEXTURES (Earth & Moon)
     * We load the exact textures required by the assignment.
     *
     * NOTE: Wikipedia images typically allow cross-origin loading,
     * but some platforms/tools may block it. If that happens in your
     * environment, try the "flat texture links" provided by your prompt.
     **************************************************************/
    const textureLoader = new THREE.TextureLoader();

    // Required textures from the assignment prompt:
    const earthTextureURL =
      "https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/300px-The_Earth_seen_from_Apollo_17.jpg";

    const moonTextureURL =
      "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/FullMoon2010.jpg/280px-FullMoon2010.jpg";

    // Optional "flat" texture links (not used by default, but included for reference):
    // const earthFlatMapURL = "https://upload.wikimedia.org/wikipedia/commons/c/cf/WorldMap-A_non-Frame.png";
    // const moonFlatMapURL  = "https://upload.wikimedia.org/wikipedia/commons/d/db/Moonmap_from_clementine_data.png";

    // Load textures
    const earthTexture = textureLoader.load(earthTextureURL);
    const moonTexture  = textureLoader.load(moonTextureURL);

    // Improve texture appearance on spheres (helps reduce blurring)
    earthTexture.colorSpace = THREE.SRGBColorSpace;
    moonTexture.colorSpace  = THREE.SRGBColorSpace;

    /**************************************************************
     * 4) CREATE SPHERE GEOMETRIES (Earth & Moon)
     **************************************************************/

    // Earth: larger sphere
    const earthRadius = 1.3;
    const earthGeometry = new THREE.SphereGeometry(earthRadius, 64, 64);

    // MeshStandardMaterial responds to lights (needed for day/night lighting)
    const earthMaterial = new THREE.MeshStandardMaterial({
      map: earthTexture,
      metalness: 0.0,
      roughness: 1.0
    });

    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    earth.position.set(0, 0, 0);
    scene.add(earth);

    // Moon: smaller sphere
    const moonRadius = 0.35;
    const moonGeometry = new THREE.SphereGeometry(moonRadius, 48, 48);

    const moonMaterial = new THREE.MeshStandardMaterial({
      map: moonTexture,
      metalness: 0.0,
      roughness: 1.0
    });

    const moon = new THREE.Mesh(moonGeometry, moonMaterial);

    /**************************************************************
     * 5) MOON ORBIT SETUP
     * We use a "pivot" (Object3D) placed at Earth's center.
     * Rotating the pivot makes the moon orbit the Earth.
     **************************************************************/
    const moonPivot = new THREE.Object3D();
    scene.add(moonPivot);

    // Orbit radius (relatively close to minimize clipping & keep eclipse visible)
    const orbitRadius = 2.2;

    // Start the moon to the LEFT of the earth (as in the promptâ€™s figure)
    // Left = negative X direction.
    moon.position.set(-orbitRadius, 0, 0);

    // Add the moon to the pivot so it orbits when pivot rotates
    moonPivot.add(moon);

    // Slight orbit tilt for visual interest (still allows eclipse alignment)
    moonPivot.rotation.z = THREE.MathUtils.degToRad(8);

    /**************************************************************
     * 6) LIGHTING
     * Requirement: Put a light source to the RIGHT of the planet
     * to expose only one side, simulating sunlight/day-night.
     **************************************************************/

    // Very dim ambient light so the "night side" isn't pure black.
    // If your instructor wants ZERO ambient, set intensity to 0.
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.08);
    scene.add(ambientLight);

    // "Sun" light: directional light placed to the RIGHT (+X).
    // DirectionalLight illuminates in a direction, like sunlight.
    const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
    sunLight.position.set(6, 1, 2); // right side of scene
    scene.add(sunLight);

    /**************************************************************
     * 7) OPTIONAL: BACKGROUND STARS (simple visual enhancement)
     * Not required, but makes it look nicer.
     **************************************************************/
    scene.background = new THREE.Color(0x000000);

    /**************************************************************
     * 8) ANIMATION LOOP
     * Requirements:
     * - Earth rotates slowly on its axis
     * - Moon rotates on its axis
     * - Moon orbits around Earth
     * - Eclipse effect: orbit passes between Earth and right-side light
     **************************************************************/
    // Control speeds here (small values = slow, smooth motion)
    const earthRotationSpeed = 0.003; // Earth axis rotation speed
    const moonRotationSpeed  = 0.01;  // Moon axis rotation speed
    const orbitSpeed         = 0.006; // Moon orbit speed

    function animate() {
      requestAnimationFrame(animate);

      // Earth rotates around its own Y-axis
      earth.rotation.y += earthRotationSpeed;

      // Moon rotates around its own Y-axis (its "day")
      moon.rotation.y += moonRotationSpeed;

      // Orbit: rotate the pivot around the Earth's Y-axis
      // This makes the moon revolve around Earth.
      moonPivot.rotation.y += orbitSpeed;

      /*
        Eclipse behavior explanation:
        - The light is positioned to the RIGHT of Earth (positive X).
        - The moon starts on the LEFT (-X), then orbits around.
        - When the moon reaches the +X side (right side),
          it will be between Earth and the light direction, producing
          an eclipse-like alignment (moon partially blocks light).
      */

      renderer.render(scene, camera);
    }
    animate();

    /**************************************************************
     * 9) HANDLE RESIZE
     * Keeps the scene correctly scaled when the window changes size.
     **************************************************************/
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
